// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using InventoryManagement.Models;
//
//    var productCodeResponse = ProductCodeResponse.FromJson(jsonString);

namespace InventoryManagement.Models
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class ProductCodeResponse
    {
        [JsonProperty("code")]
        public string Code { get; set; }

        [JsonProperty("total")]
        public long Total { get; set; }

        [JsonProperty("offset")]
        public long Offset { get; set; }

        [JsonProperty("items")]
        public List<Item> Items { get; set; }
    }

    public partial class Item
    {
        [JsonProperty("ean")]
        public string Ean { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("description")]
        public string Description { get; set; }

        [JsonProperty("upc")]
        public string Upc { get; set; }

        [JsonProperty("brand")]
        public string Brand { get; set; }

        [JsonProperty("model")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Model { get; set; }

        [JsonProperty("color")]
        public string Color { get; set; }

        [JsonProperty("size")]
        public string Size { get; set; }

        [JsonProperty("dimension")]
        public string Dimension { get; set; }

        [JsonProperty("weight")]
        public string Weight { get; set; }

        [JsonProperty("category")]
        public string Category { get; set; }

        [JsonProperty("lowest_recorded_price")]
        public long LowestRecordedPrice { get; set; }

        [JsonProperty("highest_recorded_price")]
        public long HighestRecordedPrice { get; set; }

        [JsonProperty("images")]
        public List<Uri> Images { get; set; }

        [JsonProperty("offers")]
        public List<Offer> Offers { get; set; }

        [JsonProperty("elid")]
        public string Elid { get; set; }
    }

    public partial class Offer
    {
        [JsonProperty("merchant")]
        public string Merchant { get; set; }

        [JsonProperty("domain")]
        public string Domain { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("currency")]
        public Currency Currency { get; set; }

        [JsonProperty("list_price")]
        public ListPrice ListPrice { get; set; }

        [JsonProperty("price")]
        public double Price { get; set; }

        [JsonProperty("shipping")]
        public string Shipping { get; set; }

        [JsonProperty("condition")]
        public Condition Condition { get; set; }

        [JsonProperty("availability")]
        public string Availability { get; set; }

        [JsonProperty("link")]
        public Uri Link { get; set; }

        [JsonProperty("updated_t")]
        public long UpdatedT { get; set; }
    }

    public enum Condition { New };

    public enum Currency { Cad, Empty, Gbp };

    public partial struct ListPrice
    {
        public double? Double;
        public string String;

        public static implicit operator ListPrice(double Double) => new ListPrice { Double = Double };
        public static implicit operator ListPrice(string String) => new ListPrice { String = String };
    }

    public partial class ProductCodeResponse
    {
        public static ProductCodeResponse FromJson(string json) => JsonConvert.DeserializeObject<ProductCodeResponse>(json, InventoryManagement.Models.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this ProductCodeResponse self) => JsonConvert.SerializeObject(self, InventoryManagement.Models.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ConditionConverter.Singleton,
                CurrencyConverter.Singleton,
                ListPriceConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class ConditionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Condition) || t == typeof(Condition?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "New")
            {
                return Condition.New;
            }
            throw new Exception("Cannot unmarshal type Condition");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Condition)untypedValue;
            if (value == Condition.New)
            {
                serializer.Serialize(writer, "New");
                return;
            }
            throw new Exception("Cannot marshal type Condition");
        }

        public static readonly ConditionConverter Singleton = new ConditionConverter();
    }

    internal class CurrencyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Currency) || t == typeof(Currency?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return Currency.Empty;
                case "CAD":
                    return Currency.Cad;
                case "GBP":
                    return Currency.Gbp;
            }
            throw new Exception("Cannot unmarshal type Currency");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Currency)untypedValue;
            switch (value)
            {
                case Currency.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case Currency.Cad:
                    serializer.Serialize(writer, "CAD");
                    return;
                case Currency.Gbp:
                    serializer.Serialize(writer, "GBP");
                    return;
            }
            throw new Exception("Cannot marshal type Currency");
        }

        public static readonly CurrencyConverter Singleton = new CurrencyConverter();
    }

    internal class ListPriceConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ListPrice) || t == typeof(ListPrice?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new ListPrice { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new ListPrice { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type ListPrice");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ListPrice)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type ListPrice");
        }

        public static readonly ListPriceConverter Singleton = new ListPriceConverter();
    }
}
